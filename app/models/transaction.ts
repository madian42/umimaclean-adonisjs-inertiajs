import { DateTime } from 'luxon'
import { BaseModel, belongsTo, column, hasMany } from '@adonisjs/lucid/orm'
import type { BelongsTo, HasMany } from '@adonisjs/lucid/types/relations'
import Tables from '#enums/table_enum'
import Order from './order.js'
import TransactionItem from './transaction_item.js'

/**
 * Transaction Model
 *
 * Represents a payment transaction for an order.
 * Each order can have multiple transactions (down payment + full payment).
 *
 * Business Logic:
 * - An order typically has 2 transactions:
 *   1. DOWN_PAYMENT - Initial deposit (e.g., 30-50% of total)
 *   2. FULL_PAYMENT - Remaining balance after inspection
 *
 * - Payment Flow:
 *   1. Customer creates order
 *   2. Down payment transaction created (type: 'down_payment')
 *   3. Customer pays via payment gateway (Midtrans)
 *   4. After inspection, full payment transaction created (type: 'full_payment')
 *   5. Customer pays remaining balance
 *   6. Order processing continues
 *
 * - Transaction States (status):
 *   - PENDING - Transaction created, waiting for payment
 *   - PAID - Payment successful
 *   - FAILED - Payment failed
 *   - EXPIRED - Transaction expired before payment
 *   - CANCELLED - Transaction cancelled
 *
 * - Payment Integration (Midtrans):
 *   - midtransId: Unique transaction ID from Midtrans
 *   - midtransStatus: Payment status from Midtrans
 *   - midtransQrCode: QR code for payment (QRIS)
 *   - expiredAt: Payment deadline (typically 24 hours)
 *
 * - Transaction Items:
 *   Each transaction has items (TransactionItem) that represent:
 *   - Which shoe (shoeId)
 *   - Which service (serviceId)
 *   - Price at time of transaction
 *   - Subtotal for that item
 *
 * IMPORTANT: Transaction is ALWAYS linked to an Order
 * Even for offline customers, staff creates an order first, then transaction.
 *
 * Usage Example:
 * ```typescript
 * // Create down payment transaction
 * const transaction = await Transaction.create({
 *   orderId: order.id,
 *   type: 'down_payment',
 *   amount: 100000, // 100k IDR
 *   status: TransactionStatuses.PENDING,
 *   midtransId: 'TRX-123456',
 *   midtransStatus: 'pending',
 *   midtransQrCode: 'https://...',
 *   expiredAt: DateTime.now().plus({ hours: 24 })
 * })
 *
 * // Add transaction items
 * await TransactionItem.create({
 *   transactionId: transaction.id,
 *   shoeId: shoe.id,
 *   serviceId: service.id,
 *   itemPrice: 50000,
 *   subtotal: 50000
 * })
 * ```
 */
export default class Transaction extends BaseModel {
  static table = Tables.TRANSACTIONS

  @column({ isPrimary: true })
  declare id: string

  /**
   * Reference to the order this transaction belongs to
   * REQUIRED - all transactions must be linked to an order
   *
   * NOTE: Even offline/offline transactions require an order
   * Staff should create order first, then transaction
   */
  @column()
  declare orderId: string

  /**
   * Current status of the transaction
   * Values: 'pending', 'paid', 'failed', 'expired', 'cancelled'
   * See TransactionStatuses enum for all possible values
   */
  @column()
  declare status: string

  /**
   * Type of payment
   * - 'down_payment': Initial deposit (30-50% of total)
   * - 'full_payment': Remaining balance after inspection
   *
   * Business Rule: Down payment must be paid before pickup/inspection
   * Full payment must be paid before delivery/final pickup
   */
  @column()
  declare type: 'down_payment' | 'full_payment'

  /**
   * Total amount to be paid for this transaction
   * Sum of all transaction items' subtotals
   * Stored in smallest currency unit (e.g., IDR without decimals)
   */
  @column()
  declare amount: number

  /**
   * Payment status from Midtrans payment gateway
   * Examples: 'pending', 'settlement', 'deny', 'expire', 'cancel'
   * Updated via Midtrans webhook notifications
   */
  @column()
  declare midtransStatus: string

  /**
   * Unique transaction ID from Midtrans
   * Used to track payment in Midtrans system
   * Required for payment status checks and refunds
   */
  @column()
  declare midtransId: string

  /**
   * QR code URL for QRIS payment method
   * Generated by Midtrans for QR-based payments
   * Customer scans this code to pay via mobile banking
   */
  @column()
  declare midtransQrCode: string

  /**
   * Payment deadline
   * Transaction expires if not paid by this time
   * Typically set to 24 hours from creation
   * Midtrans will automatically reject payments after expiry
   */
  @column.dateTime()
  declare expiredAt: DateTime

  /**
   * Timestamp when payment was successfully completed
   * NULL if payment not yet received
   * Set when status changes to 'paid' or Midtrans status is 'settlement'
   */
  @column.dateTime()
  declare paymentAt: DateTime | null

  /**
   * Timestamp when transaction was created
   */
  @column.dateTime({ autoCreate: true })
  declare createdAt: DateTime

  /**
   * Timestamp when transaction was last updated
   * Updated when status changes or payment is received
   */
  @column.dateTime({ autoCreate: true, autoUpdate: true })
  declare updatedAt: DateTime

  /**
   * Order this transaction belongs to
   * Load with: await transaction.load('order')
   */
  @belongsTo(() => Order, {
    foreignKey: 'orderId',
  })
  declare order: BelongsTo<typeof Order>

  /**
   * Line items in this transaction
   * Each item represents: shoe + service + price
   * Total amount = sum of all items' subtotals
   *
   * Example: Customer orders cleaning for 2 shoes
   * - Item 1: Nike shoes + Deep Cleaning = 50k
   * - Item 2: Adidas shoes + Basic Cleaning = 30k
   * - Total transaction amount = 80k
   */
  @hasMany(() => TransactionItem, {
    foreignKey: 'transactionId',
  })
  declare items: HasMany<typeof TransactionItem>
}
